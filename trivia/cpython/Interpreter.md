## Interpreted Language
Python is dubbed an interpreted language but it actually involves a compilation stage. The reason Python is still called interpreted is that the compilation step is not what is generating the machine level code. 

## About the Interpreter
The python interpreter is a virtual machine, meaning it is software which emulates a physical computer. Python in particular is a stack machine rather than a register machine. 

The Interpreter is equipped to work with bytecode. The lexer, parser, and compiler get us to the bytecode, then the interpreter handles it. 

Note that there are several advantages for generating this byte code in that code objects do not need to be recreated on every run. 

## Checking out the func and byte code
```python
>>> def mod(a,b):
...     ans = a % b
...     return ans
... 
>>> dis.dis(mod)
  2           0 LOAD_FAST                0 (a)
              2 LOAD_FAST                1 (b)
              4 BINARY_MODULO
              6 STORE_FAST               2 (ans)

  3           8 LOAD_FAST                2 (ans)
             10 RETURN_VALUE
```
Notice that binary modulo does not take any arguments, its only looking at the values which are on the stack

## There are 2 stacks
Note that interpreter is actually made up of 2 stacks. 
- The call stack
- The data stack (note that there is one of these per frame on the call stack)
    - As a fun aside the only python functionality which requires one data stack per frame on the call stack is the *generator* functionality
The call stack which holds the set of function calls, and the data stack which holds the data or arguments to ecah of those functions calls.

We can use the dis standard lib to inspect the byte code generated by the compiler to understand where data is being stored on the stack, and how much work the interpreter is doing
```python
>>> def fact(n):
...     if n < 1:
...             return 1
...     return n * fact(n-1)
... 
>>> fact(3)
6
>>> dis.dis(fact)
  2           0 LOAD_FAST                0 (n)
              2 LOAD_CONST               1 (1)
              4 COMPARE_OP               0 (<)
              6 POP_JUMP_IF_FALSE       12

  3           8 LOAD_CONST               1 (1)
             10 RETURN_VALUE

  4     >>   12 LOAD_FAST                0 (n)
             14 LOAD_GLOBAL              0 (fact) # note the load of the function frame off of the data stack onto the call stack
             16 LOAD_FAST                0 (n)
             18 LOAD_CONST               1 (1)
             20 BINARY_SUBTRACT
             22 CALL_FUNCTION            1
             24 BINARY_MULTIPLY
             26 RETURN_VALUE
```

## Into Cpython
Inside of c_eval.c, which is the source code for the python interpreter there is a 1500 line switch statement for all of the different opcodes.

Note that in python 3 and up there is instead a computed go to value.

## Dynamic Programming Languages
```python
>>> def mod(a,b):
...     ans = a % b
...     return ans
... 
>>> mod(15, 4)
3
>>> mod("%s%s", ("Py", "Con"))
'PyCon'
```

We already know that the syntax for string formatting is
```python
"%s%s" % ("Py", "Con")
```

Which means (referring) to the disassembled output from above, we know that binary modulo is still what is being called! So long at the correct values are on the stack we can push whatever we want on there. The compiler does not know and does not care about the distinction between string and int! The ignorance of the comiler goes deeper than this, we could even go so far as to define *\__mod__* on a custom object

```python
>>> class ModObj(object):
...     def __mod__(self, other):
...             print("You triggered my mod method")
... 
>>> s = ModObj()
>>> t = ModObj()
>>> s % t
You triggered my mod method
```

The language being so dynamic make it very difficult to reason about which opcodes are redudant/ how the langauge can be made more performant.

```
In the general absence of type information, almost every instruction must be treated as INVOKE_ARBITRARY_METHOD
```

The caveat being that we can add type information and the static analysis will be much faster.

## References
- https://www.youtube.com/watch?v=HVUTjQzESeo
- https://arxiv.org/pdf/1306.6047.pdf